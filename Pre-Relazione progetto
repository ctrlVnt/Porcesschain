PROCESSO MASTER
	-padre di tutti i figli
	-gestisce la simulazione 
	-crea il LIBRO MASTRO
	-stampa periodicamente i bilanci dei PROCESSI UTENTE e NODO e per farlo accede al LIBRO MASTRO

PROCESSI UTENTE
	-creano e inviano transazioni ai PROCESSI NODO 
	-ha un BUDGET INIZIALE uguale per tutti
	-CICLO DI VITA:
		-calcola il bilancio corrente = BUDGET INIZIALE facendo la somma algebrica (entrate e uscite) 
	     sottraendo le uscite non registrare nel LIBRO MASTRO
		-estrae casualmente un nodo a cui inviare soldi e attende un INTERVALLO DI TEMPO
	-genera una transazioni in risposta ad un segnale(scelto da noi mascherato)
	
	GESTIONE INVIO TRANSAZIONE E ATTESA
		calcolo bilancio corrente(funzione)
		maschero segnali
		invio transazione(funzione)
		smaschero segnali
		nanosleep(attesaTOTALE, attesaRIMANENTE)
			eventuale gestione segnale(eve
			ntuale nuova transazione)
		se attesaRIMANENTE == 0 continuo normalmente, altrimenti richiamo 
		nanosleep(attesaRIMANENTE, ...) -> possibile ciclo while(attesaRIMANENTE != 0)
		continua esecuzione
		dopo aver tentato SO_RETRY di inviare volte e non ho i soldi per farlo, termino il processo utente
		notificando il MASTER(possibili implementazione di attesa dopo ciuascun SO_RETRY)
		
PROCESSI NODO
	-memorizza privatamente la lista di transazioni ricevute da processare -- transaction pool
		* array di transazioni ??? memoria condivisa ???
	-se transaction pool e' PIENA allora ogni ulteriore transazione viene SCARTATA e non eseguita e sender informato
		**(ATTENZIONE punto da gestire in caso di verione "normal"!!!)
	-transazioni processate in BLOCCHI, ogni BLOCCO contiene un SO_BLOCK_SIZE di transazioni di cui
	1 e' la transazione di pagamento e il resto sono le transazioni ricevute.
	-CICLO DI VITA:
		-Creazione di un blocco candidato
			-Estrazione un insieme massimo di SO_BLOCK_SIZE-1 transazioni non ancora presenti nel libro.
		-Simulazione dell'elaborazione attraverso una attesa non attiva(valore compreso tra SO_MIN_TRANS... SO_MAX_TRANS...)

LIBRO MASTRO(una risorsa condivisa!!!)
	-Accessibile sia ai nodi che agli utenti 
	-Memorizza le transazioni ESEGUITE
	-Transazione CONFERMATA se e solo se ENTRA a far parte del libro mastro
	-E' formato da una sequenza di blocchi(lunghezza massima SO_REGISTRY_SIZE) consecutivi.
	-Ogni blocco e' identificato da un ID intero progressivo
	-Transazione memorizzata e' identificata da una TRIPLETA: timestamp, sender, receiver.

-TERMINAZIONE:
	-SO_SECONDI: alarm!!! (proc. master); 
	-Capacita' del libro master si esaurisce: controllo prima di registrare una transaction, oppure indice eccede SO_REGISTRY_SIZE!!!
	*** obbliggare tutti i proc. nodi e i proc. utenti di terminare

-TRANSAZIONE
	-sorteggio usando mappa <int><string> (int = pid) (string =flag(vivo,morto.....)) ???
	